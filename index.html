<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Sensor Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            gap: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        select, input {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .views-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .view {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            flex: 1;
            min-width: 600px;
        }

        .view-header {
            background-color: #333;
            color: white;
            padding: 10px 15px;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
        }

        canvas {
            display: block;
            background-color: #f9f9f9;
        }

        .status-panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            margin-top: 20px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .status-item {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }

        .status-label {
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        }

        .status-value {
            color: #333;
        }

        .sensor-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .sensor-control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .sensor-control-item label {
            font-size: 12px;
            color: #666;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            padding: 8px 16px;
            background-color: #ddd;
        }

        .mode-btn.active {
            background-color: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2D Residential Thermal-Sensor Simulation System</h1>
            <p>Dual WebView with Movable Character and Sensors</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="roomType">Room Type:</label>
                <select id="roomType">
                    <option value="bedroom">Bedroom</option>
                    <option value="living">Living Room</option>
                    <option value="kitchen">Kitchen</option>
                    <option value="bathroom">Bathroom</option>
                </select>
            </div>

            <div class="control-group">
                <label for="objectType">Place Object:</label>
                <select id="objectType">
                    <option value="character">Character</option>
                    <option value="sensor">Thermal Sensor</option>
                    <option value="furniture">Furniture</option>
                </select>
            </div>

            <div class="control-group">
                <label for="characterState">Character State:</label>
                <select id="characterState">
                    <option value="standing">Standing</option>
                    <option value="sitting">Sitting</option>
                    <option value="lying">Lying Down</option>
                    <option value="crawling">Crawling</option>
                    <option value="fallen">Fallen</option>
                </select>
            </div>

            <div class="control-group">
                <button id="resetBtn">Reset Scene</button>
            </div>
        </div>

        <div class="views-container">
            <div class="view">
                <div class="view-header">WebView A - Top-Down View</div>
                <div class="canvas-container">
                    <canvas id="topDownCanvas" width="600" height="500"></canvas>
                </div>
            </div>

            <div class="view">
                <div class="view-header">WebView B - Side View</div>
                <div class="canvas-container">
                    <canvas id="sideViewCanvas" width="600" height="500"></canvas>
                </div>
            </div>
        </div>

        <div class="view">
            <div class="view-header">Thermal Sensor Output (256x256 Grid)</div>
            <div class="canvas-container">
                <canvas id="thermalOutputCanvas" width="256" height="256" style="width: 512px; height: 512px;"></canvas>
            </div>
        </div>

        <div class="status-panel">
            <h3>Character Status</h3>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">Position</div>
                    <div class="status-value" id="positionStatus">(0, 0)</div>
                </div>
                <div class="status-item">
                    <div class="status-label">State</div>
                    <div class="status-value" id="stateStatus">Standing</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Posture</div>
                    <div class="status-value" id="postureStatus">Upright</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Danger Level</div>
                    <div class="status-value" id="dangerStatus">Low</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Movement</div>
                    <div class="status-value" id="movementStatus">Idle</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Occlusion</div>
                    <div class="status-value" id="occlusionStatus">None</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        const state = {
            roomType: 'bedroom',
            objectType: 'character',
            characterState: 'standing',
            mode: 'place', // place, move, select
            selectedObject: null,
            
            // Scene objects
            character: { x: 300, y: 250, state: 'standing', posture: 'upright' },
            sensors: [
                { id: 1, x: 50, y: 100, angle: 45, fov: 60, active: true }
            ],
            furniture: [
                { type: 'bed', x: 400, y: 350, width: 80, height: 120 },
                { type: 'table', x: 200, y: 200, width: 60, height: 60 },
                { type: 'chair', x: 150, y: 220, width: 30, height: 30 }
            ],
            
            // Thermal output
            thermalGrid: Array(256).fill().map(() => Array(256).fill(0))
        };

        // Canvas elements
        const topDownCanvas = document.getElementById('topDownCanvas');
        const sideViewCanvas = document.getElementById('sideViewCanvas');
        const thermalOutputCanvas = document.getElementById('thermalOutputCanvas');
        const ctxTop = topDownCanvas.getContext('2d');
        const ctxSide = sideViewCanvas.getContext('2d');
        const ctxThermal = thermalOutputCanvas.getContext('2d');

        // Initialize the application
        function init() {
            setupEventListeners();
            drawScene();
            
            // Start animation loop
            setInterval(updateAndDraw, 50);
        }

        function setupEventListeners() {
            // Control panel events
            document.getElementById('roomType').addEventListener('change', (e) => {
                state.roomType = e.target.value;
                drawScene();
            });

            document.getElementById('objectType').addEventListener('change', (e) => {
                state.objectType = e.target.value;
            });

            document.getElementById('characterState').addEventListener('change', (e) => {
                state.character.state = e.target.value;
                updateCharacterPosture();
                drawScene();
            });

            document.getElementById('resetBtn').addEventListener('click', resetScene);

            // Canvas event listeners
            topDownCanvas.addEventListener('mousedown', handleCanvasMouseDown);
            topDownCanvas.addEventListener('mousemove', handleCanvasMouseMove);
            topDownCanvas.addEventListener('mouseup', handleCanvasMouseUp);

            // Keyboard controls for character movement
            document.addEventListener('keydown', handleKeyDown);
        }

        function handleCanvasMouseDown(e) {
            const rect = topDownCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on existing object
            let clickedObject = null;

            // Check character
            if (distance(x, y, state.character.x, state.character.y) < 20) {
                clickedObject = { type: 'character', obj: state.character };
            }

            // Check sensors
            for (const sensor of state.sensors) {
                if (distance(x, y, sensor.x, sensor.y) < 15) {
                    clickedObject = { type: 'sensor', obj: sensor };
                    break;
                }
            }

            // Check furniture
            for (const furn of state.furniture) {
                if (x >= furn.x && x <= furn.x + furn.width && 
                    y >= furn.y && y <= furn.y + furn.height) {
                    clickedObject = { type: 'furniture', obj: furn };
                    break;
                }
            }

            if (clickedObject) {
                state.selectedObject = clickedObject;
                state.mode = 'move';
            } else if (state.objectType === 'character') {
                state.character.x = x;
                state.character.y = y;
            } else if (state.objectType === 'sensor') {
                state.sensors.push({
                    id: Date.now(),
                    x: x,
                    y: y,
                    angle: 45,
                    fov: 60,
                    active: true
                });
            } else if (state.objectType === 'furniture') {
                // Add default furniture
                state.furniture.push({
                    type: 'table',
                    x: x,
                    y: y,
                    width: 60,
                    height: 60
                });
            }

            drawScene();
        }

        function handleCanvasMouseMove(e) {
            if (!state.selectedObject || state.mode !== 'move') return;

            const rect = topDownCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (state.selectedObject.type === 'character') {
                state.selectedObject.obj.x = x;
                state.selectedObject.obj.y = y;
            } else if (state.selectedObject.type === 'sensor') {
                state.selectedObject.obj.x = x;
                state.selectedObject.obj.y = y;
            } else if (state.selectedObject.type === 'furniture') {
                state.selectedObject.obj.x = x;
                state.selectedObject.obj.y = y;
            }

            drawScene();
        }

        function handleCanvasMouseUp(e) {
            state.mode = 'place';
            state.selectedObject = null;
        }

        function handleKeyDown(e) {
            // Move character with arrow keys
            if (e.key.startsWith('Arrow')) {
                const speed = 5;
                switch(e.key) {
                    case 'ArrowUp':
                        state.character.y -= speed;
                        break;
                    case 'ArrowDown':
                        state.character.y += speed;
                        break;
                    case 'ArrowLeft':
                        state.character.x -= speed;
                        break;
                    case 'ArrowRight':
                        state.character.x += speed;
                        break;
                }
                
                // Keep character within bounds
                state.character.x = Math.max(10, Math.min(topDownCanvas.width - 10, state.character.x));
                state.character.y = Math.max(10, Math.min(topDownCanvas.height - 10, state.character.y));
                
                drawScene();
            }
        }

        function updateCharacterPosture() {
            switch(state.character.state) {
                case 'standing':
                    state.character.posture = 'upright';
                    break;
                case 'sitting':
                    state.character.posture = 'seated';
                    break;
                case 'lying':
                    state.character.posture = 'horizontal';
                    break;
                case 'crawling':
                    state.character.posture = 'low-profile';
                    break;
                case 'fallen':
                    state.character.posture = 'prostrate';
                    break;
            }
        }

        function updateAndDraw() {
            updateThermalOutput();
            updateStatusPanel();
            drawScene();
        }

        function updateThermalOutput() {
            // Clear thermal grid
            state.thermalGrid = Array(256).fill().map(() => Array(256).fill(0));
            
            // Process each active sensor
            for (const sensor of state.sensors) {
                if (!sensor.active) continue;
                
                // Calculate sensor's field of view
                const sensorAngleRad = sensor.angle * Math.PI / 180;
                const fovHalfRad = (sensor.fov / 2) * Math.PI / 180;
                
                // For each cell in the 256x256 grid, check if it's in sensor's FOV
                for (let y = 0; y < 256; y++) {
                    for (let x = 0; x < 256; x++) {
                        // Convert grid coordinates to world coordinates
                        const worldX = (x / 256) * topDownCanvas.width;
                        const worldY = (y / 256) * topDownCanvas.height;
                        
                        // Calculate vector from sensor to this point
                        const dx = worldX - sensor.x;
                        const dy = worldY - sensor.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance === 0) continue;
                        
                        // Calculate angle from sensor to this point
                        const pointAngle = Math.atan2(dy, dx);
                        const relAngle = pointAngle - sensorAngleRad;
                        
                        // Normalize angle to [-π, π]
                        let normalizedAngle = ((relAngle + Math.PI) % (2 * Math.PI)) - Math.PI;
                        
                        // Check if point is within FOV
                        if (Math.abs(normalizedAngle) <= fovHalfRad && distance <= 400) {
                            // Calculate heat intensity based on distance and character presence
                            const charDist = distance(state.character.x, state.character.y, worldX, worldY);
                            
                            if (charDist < 30) { // Character is here
                                // Base heat intensity (varies by state)
                                let heat = 0.8;
                                
                                // Modify by state
                                switch(state.character.state) {
                                    case 'lying': heat *= 1.2; break;
                                    case 'sitting': heat *= 1.1; break;
                                    case 'crawling': heat *= 0.9; break;
                                    case 'fallen': heat *= 1.3; break;
                                }
                                
                                // Apply occlusion from furniture
                                if (isOccluded(sensor.x, sensor.y, worldX, worldY)) {
                                    heat *= 0.3; // Significant reduction when occluded
                                }
                                
                                // Add some noise for realism
                                heat += (Math.random() - 0.5) * 0.1;
                                
                                // Clamp to valid range
                                heat = Math.max(0, Math.min(1, heat));
                                
                                state.thermalGrid[y][x] = heat;
                            } else {
                                // Check for furniture heat sources
                                for (const furn of state.furniture) {
                                    if (furn.type === 'stove' || furn.type === 'radiator') {
                                        const furnDist = distance(furn.x + furn.width/2, furn.y + furn.height/2, worldX, worldY);
                                        if (furnDist < 40) {
                                            state.thermalGrid[y][x] = Math.max(state.thermalGrid[y][x], 0.6);
                                        }
                                    }
                                }
                                
                                // Add ambient noise
                                if (state.thermalGrid[y][x] === 0) {
                                    state.thermalGrid[y][x] = Math.random() * 0.05;
                                }
                            }
                        }
                    }
                }
            }
            
            // Draw the thermal grid
            drawThermalOutput();
        }

        function isOccluded(sx, sy, ex, ey) {
            // Simple occlusion check - see if any furniture blocks line of sight
            for (const furn of state.furniture) {
                if (lineIntersectsRect(sx, sy, ex, ey, furn.x, furn.y, furn.x + furn.width, furn.y + furn.height)) {
                    return true;
                }
            }
            return false;
        }

        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rxe, rye) {
            // Check if line intersects with rectangle
            // Using line segment vs axis-aligned rectangle intersection
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);

            if (maxX < rx || minX > rxe || maxY < ry || minY > rye) {
                return false; // Bounding box check
            }

            // More accurate line-rectangle intersection test
            // Calculate the line equation Ax + By + C = 0
            const A = y2 - y1;
            const B = x1 - x2;
            const C = A * x1 + B * y1;

            // Check which side of the line each corner of the rectangle is on
            const f = (x, y) => A * x + B * y - C;
            
            const corners = [
                [rx, ry],
                [rxe, ry],
                [rxe, rye],
                [rx, rye]
            ];
            
            let signChanges = 0;
            for (let i = 0; i < 4; i++) {
                const j = (i + 1) % 4;
                const sign1 = Math.sign(f(corners[i][0], corners[i][1]));
                const sign2 = Math.sign(f(corners[j][0], corners[j][1]));
                
                if (sign1 !== sign2 && sign1 !== 0 && sign2 !== 0) {
                    signChanges++;
                }
            }
            
            return signChanges >= 2;
        }

        function drawThermalOutput() {
            const imageData = ctxThermal.createImageData(256, 256);
            
            for (let y = 0; y < 256; y++) {
                for (let x = 0; x < 256; x++) {
                    const value = state.thermalGrid[y][x];
                    const idx = (y * 256 + x) * 4;
                    
                    // Map thermal value to color (red for heat, blue for cold)
                    const intensity = Math.floor(value * 255);
                    
                    // Red component increases with heat
                    imageData.data[idx] = intensity;       // R
                    imageData.data[idx + 1] = intensity * 0.3;     // G  
                    imageData.data[idx + 2] = 255 - intensity;     // B
                    imageData.data[idx + 3] = 255;       // A
                }
            }
            
            ctxThermal.putImageData(imageData, 0, 0);
        }

        function updateStatusPanel() {
            document.getElementById('positionStatus').textContent = 
                `(${Math.round(state.character.x)}, ${Math.round(state.character.y)})`;
            document.getElementById('stateStatus').textContent = 
                capitalizeFirstLetter(state.character.state);
            document.getElementById('postureStatus').textContent = 
                capitalizeFirstLetter(state.character.posture);
            
            // Determine danger level
            let dangerLevel = 'Low';
            if (state.character.state === 'fallen' || state.character.posture === 'prostrate') {
                dangerLevel = 'High';
            } else if (state.character.state === 'lying' && state.character.x > 500) {
                dangerLevel = 'Medium'; // Far from safe area
            }
            document.getElementById('dangerStatus').textContent = dangerLevel;
            
            // Movement status
            document.getElementById('movementStatus').textContent = 
                state.character.state === 'standing' ? 'Active' : 'Inactive';
            
            // Occlusion status
            let occlusion = 'None';
            for (const sensor of state.sensors) {
                if (isOccluded(sensor.x, sensor.y, state.character.x, state.character.y)) {
                    occlusion = 'Partial';
                    break;
                }
            }
            document.getElementById('occlusionStatus').textContent = occlusion;
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function drawScene() {
            // Clear canvases
            ctxTop.clearRect(0, 0, topDownCanvas.width, topDownCanvas.height);
            ctxSide.clearRect(0, 0, sideViewCanvas.width, sideViewCanvas.height);

            // Draw room layout based on type
            drawRoom(ctxTop, state.roomType);

            // Draw furniture
            for (const furn of state.furniture) {
                drawFurniture(ctxTop, furn);
            }

            // Draw sensors
            for (const sensor of state.sensors) {
                drawSensor(ctxTop, sensor);
            }

            // Draw character
            drawCharacter(ctxTop, state.character);

            // Draw side view
            drawSideView(ctxSide);
        }

        function drawRoom(ctx, roomType) {
            // Draw basic room outline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.strokeRect(10, 10, topDownCanvas.width - 20, topDownCanvas.height - 20);

            // Draw room-specific features
            switch(roomType) {
                case 'bedroom':
                    // Draw closet
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(50, 50, 60, 100);
                    ctx.strokeRect(50, 50, 60, 100);
                    break;
                case 'living':
                    // Draw TV unit
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(50, 400, 100, 30);
                    ctx.strokeRect(50, 400, 100, 30);
                    break;
                case 'kitchen':
                    // Draw counter
                    ctx.fillStyle = '#A9A9A9';
                    ctx.fillRect(50, 300, 200, 30);
                    ctx.strokeRect(50, 300, 200, 30);
                    break;
                case 'bathroom':
                    // Draw toilet
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(500, 400, 40, 50);
                    ctx.strokeRect(500, 400, 40, 50);
                    break;
            }
        }

        function drawFurniture(ctx, furn) {
            switch(furn.type) {
                case 'bed':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(furn.x, furn.y, furn.width, furn.height);
                    ctx.strokeStyle = '#5D2906';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(furn.x, furn.y, furn.width, furn.height);
                    break;
                case 'table':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(furn.x, furn.y, furn.width, furn.height);
                    ctx.strokeStyle = '#5D2906';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(furn.x, furn.y, furn.width, furn.height);
                    break;
                case 'chair':
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(furn.x, furn.y, furn.width, furn.height);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(furn.x, furn.y, furn.width, furn.height);
                    break;
                case 'stove':
                    ctx.fillStyle = '#333';
                    ctx.fillRect(furn.x, furn.y, furn.width, furn.height);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(furn.x, furn.y, furn.width, furn.height);
                    // Draw burners
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(furn.x + 15, furn.y + 15, 5, 0, Math.PI * 2);
                    ctx.arc(furn.x + 45, furn.y + 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }
        }

        function drawSensor(ctx, sensor) {
            // Draw sensor base
            ctx.fillStyle = sensor.active ? '#00FF00' : '#888888';
            ctx.beginPath();
            ctx.arc(sensor.x, sensor.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw FOV
            if (sensor.active) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                
                const startAngle = (sensor.angle - sensor.fov/2) * Math.PI / 180;
                const endAngle = (sensor.angle + sensor.fov/2) * Math.PI / 180;
                
                ctx.beginPath();
                ctx.moveTo(sensor.x, sensor.y);
                ctx.arc(sensor.x, sensor.y, 100, startAngle, endAngle);
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw sensor info
            ctx.fillStyle = '#000';
            ctx.font = '10px Arial';
            ctx.fillText(`ID:${sensor.id}`, sensor.x + 10, sensor.y - 10);
        }

        function drawCharacter(ctx, character) {
            const { x, y, state: charState } = character;
            
            // Draw character based on state
            ctx.fillStyle = '#FF6B6B';
            
            switch(charState) {
                case 'standing':
                    // Draw standing person (simple circle)
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(x, y + 10);
                    ctx.lineTo(x, y + 30);
                    ctx.stroke();
                    
                    // Arms
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y + 15);
                    ctx.lineTo(x + 8, y + 15);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(x, y + 30);
                    ctx.lineTo(x - 8, y + 45);
                    ctx.moveTo(x, y + 30);
                    ctx.lineTo(x + 8, y + 45);
                    ctx.stroke();
                    break;
                    
                case 'sitting':
                    // Draw sitting person
                    ctx.beginPath();
                    ctx.arc(x, y - 5, 8, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Body
                    ctx.fillRect(x - 8, y - 5, 16, 20); // Torso
                    
                    // Legs bent
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y + 15);
                    ctx.lineTo(x - 15, y + 25);
                    ctx.moveTo(x + 8, y + 15);
                    ctx.lineTo(x + 15, y + 25);
                    ctx.stroke();
                    break;
                    
                case 'lying':
                    // Draw lying person (horizontal)
                    ctx.beginPath();
                    ctx.rect(x - 15, y - 5, 30, 10); // Body
                    ctx.fill();
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(x - 18, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'crawling':
                    // Draw crawling person
                    ctx.beginPath();
                    ctx.arc(x, y - 3, 7, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Body low
                    ctx.beginPath();
                    ctx.rect(x - 10, y - 3, 20, 8); // Low body
                    ctx.fill();
                    
                    // Limbs
                    ctx.beginPath();
                    ctx.moveTo(x - 10, y + 2);
                    ctx.lineTo(x - 15, y + 5);
                    ctx.moveTo(x + 10, y + 2);
                    ctx.lineTo(x + 15, y + 5);
                    ctx.stroke();
                    break;
                    
                case 'fallen':
                    // Draw fallen person
                    ctx.beginPath();
                    ctx.arc(x + 5, y, 6, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Disoriented body
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(Math.PI / 4); // Rotated
                    ctx.fillRect(-10, -3, 20, 8);
                    ctx.restore();
                    break;
            }
        }

        function drawSideView(ctx) {
            // Draw simple side view representation
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, sideViewCanvas.width, sideViewCanvas.height);
            
            // Draw walls
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(550, 50); // Ceiling
            ctx.lineTo(550, 450); // Right wall
            ctx.lineTo(50, 450); // Floor
            ctx.lineTo(50, 50); // Left wall
            ctx.stroke();
            
            // Draw character in side view based on state
            const charX = 300;
            const charY = 400;
            
            ctx.fillStyle = '#FF6B6B';
            
            switch(state.character.state) {
                case 'standing':
                    // Draw standing figure
                    ctx.beginPath();
                    ctx.arc(charX, charY - 40, 8, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Body
                    ctx.beginPath();
                    ctx.moveTo(charX, charY - 32);
                    ctx.lineTo(charX, charY - 10);
                    ctx.stroke();
                    
                    // Legs
                    ctx.beginPath();
                    ctx.moveTo(charX, charY - 10);
                    ctx.lineTo(charX - 10, charY + 5);
                    ctx.moveTo(charX, charY - 10);
                    ctx.lineTo(charX + 10, charY + 5);
                    ctx.stroke();
                    break;
                    
                case 'sitting':
                    // Draw sitting figure
                    ctx.beginPath();
                    ctx.arc(charX, charY - 35, 7, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Bent body
                    ctx.beginPath();
                    ctx.rect(charX - 10, charY - 25, 20, 15); // Torso
                    ctx.fill();
                    
                    // Bent legs
                    ctx.beginPath();
                    ctx.moveTo(charX - 10, charY - 10);
                    ctx.lineTo(charX - 15, charY + 5);
                    ctx.moveTo(charX + 10, charY - 10);
                    ctx.lineTo(charX + 15, charY + 5);
                    ctx.stroke();
                    break;
                    
                case 'lying':
                    // Draw lying figure (from side)
                    ctx.beginPath();
                    ctx.ellipse(charX - 15, charY - 5, 8, 5, 0, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    // Horizontal body
                    ctx.beginPath();
                    ctx.rect(charX - 15, charY - 8, 35, 6); // Body
                    ctx.fill();
                    break;
                    
                case 'crawling':
                    // Draw crawling figure
                    ctx.beginPath();
                    ctx.arc(charX, charY - 30, 6, 0, Math.PI * 2); // Head down
                    ctx.fill();
                    
                    // Low body
                    ctx.beginPath();
                    ctx.rect(charX - 8, charY - 25, 16, 10); // Low profile body
                    ctx.fill();
                    break;
                    
                case 'fallen':
                    // Draw fallen figure
                    ctx.save();
                    ctx.translate(charX, charY - 20);
                    ctx.rotate(Math.PI / 6); // Tilted
                    ctx.beginPath();
                    ctx.arc(0, 0, 7, 0, Math.PI * 2); // Head
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.rect(-12, -5, 24, 12); // Body
                    ctx.fill();
                    ctx.restore();
                    break;
            }
            
            // Draw furniture in side view
            for (const furn of state.furniture) {
                if (furn.type === 'bed') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(400, 380, 80, 20);
                } else if (furn.type === 'table') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(180, 400, 60, 15);
                }
            }
        }

        function resetScene() {
            state.character = { x: 300, y: 250, state: 'standing', posture: 'upright' };
            state.sensors = [
                { id: 1, x: 50, y: 100, angle: 45, fov: 60, active: true }
            ];
            state.furniture = [
                { type: 'bed', x: 400, y: 350, width: 80, height: 120 },
                { type: 'table', x: 200, y: 200, width: 60, height: 60 },
                { type: 'chair', x: 150, y: 220, width: 30, height: 30 }
            ];
            
            document.getElementById('characterState').value = 'standing';
            drawScene();
        }

        // Initialize the application when the page loads
        window.onload = init;
    </script>
</body>
</html>